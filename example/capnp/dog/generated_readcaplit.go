package dog

// AUTO GENERATED - DO NOT EDIT
// GENERATED BY gen_readcaplit.go

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"strconv"

	"github.com/glycerine/go-capnproto"
)

func arrayInStringParser(s string) []string {
	s = s[1 : len(s)-1]
	l := len(s)
	innerCount := 0
	buff := ""
	ret_val := make([]string, 0)
	for i := 0; i < l; i++ {
		target := string(s[i])

		switch target {
		case "[":
			fallthrough
		case "(":
			innerCount++
			buff += target
		case "]":
			fallthrough
		case ")":
			innerCount--
			buff += target
		case ",":
			if innerCount == 0 {
				ret_val = append(ret_val, buff)
				buff = ""
			} else {
				buff += target
			}
		default:
			buff += target
		}
	}
	if buff != "" {
		ret_val = append(ret_val, buff)
	}
	return ret_val
}

func capLitParser() func(string) (string, string, string, bool) {
	const None = 0
	const In = 1
	const Key = 2
	const Value = 3

	status := None
	substatus := ""
	key := ""
	value := ""
	innerCount := 0
	inQuote := false

	return func(c string) (string, string, string, bool) {
		if substatus == "flush" {
			substatus = ""
			key = ""
			value = ""
		}

		if status == None {
			switch c {
			case "(":
				status = Key
			case ")":
				status = None
			default:
				panic(fmt.Sprintf("parse error : None status, %s", c))
			}
		} else if status == In {
			switch c {
			case ",":
				status = Key
			}
		} else if status == Key {
			switch c {
			case "=":
				status = Value
			case " ":
			default:
				key += c
			}
		} else if status == Value {
			// array( [] ), group(), struct(), plain text
			if inQuote {
				value += c
			} else if substatus == "plain" {
				switch c {
				case ",":
					status = Key
					fallthrough
				case ")":
					substatus = "flush"
				default:
					value += c
				}
			} else if substatus == "(" {
				value += c
				switch c {
				case "(":
					innerCount++
				case ")":
					innerCount--
					if innerCount < 0 {
						panic("parse error : ( and ) does not match")
					} else if innerCount == 0 {
						substatus = "flush"
						status = In
					}
				}
			} else if substatus == "[" {
				value += c
				switch c {
				case "[":
					innerCount++
				case "]":
					innerCount--
					if innerCount < 0 {
						panic("parse error : [ and ] does not match")
					} else if innerCount == 0 {
						substatus = "flush"
						status = In
					}
				}
			} else {
				value += c
				switch c {
				case "[":
					fallthrough
				case "(":
					innerCount++
					substatus = c
				default:
					substatus = "plain"
				}
			}
		}

		if c == "\"" {
			inQuote = !inQuote
		}

		return substatus, key, value, inQuote
	}
}

func (s DogToy) ReadCapLit(r io.Reader) error {
	b := bufio.NewReader(r)
	parseError := errors.New("Parse error")
	var substatus, key, value string
	var inQuote bool
	parser := capLitParser()
	for {
		b, err := b.ReadByte()
		if err != nil {
			break
		}

		c := string(b)
		if c == "\n" || c == "\t" {
			continue
		}

		if c == " " && !inQuote {
			continue
		}

		substatus, key, value, inQuote = parser(c)

		if substatus == "flush" {
			switch key {

			case "id":
				v, err := strconv.ParseInt(value, 10, 32)
				if err != nil {
					return err
				}
				s.SetId(int32(v))

			case "price":
				v, err := strconv.ParseInt(value, 10, 64)
				if err != nil {
					return err
				}
				s.SetPrice(v)

			case "toyType":
				v := ToyTypeFromString(value)
				s.SetToyType(v)

			default:
				return parseError
			}

			substatus = ""
		}
	}

	if substatus != "" {
		return parseError
	}

	return nil
}

func (s DogToy) GetSegment() *capn.Segment { return s.Segment }

func (s Dog) ReadCapLit(r io.Reader) error {
	b := bufio.NewReader(r)
	parseError := errors.New("Parse error")
	var substatus, key, value string
	var inQuote bool
	parser := capLitParser()
	for {
		b, err := b.ReadByte()
		if err != nil {
			break
		}

		c := string(b)
		if c == "\n" || c == "\t" {
			continue
		}

		if c == " " && !inQuote {
			continue
		}

		substatus, key, value, inQuote = parser(c)

		if substatus == "flush" {
			switch key {

			case "id":
				v, err := strconv.ParseInt(value, 10, 32)
				if err != nil {
					return err
				}
				s.SetId(int32(v))

			case "name":
				s.SetName(value[1 : len(value)-1])

			case "age":
				v, err := strconv.ParseInt(value, 10, 8)
				if err != nil {
					return err
				}
				s.SetAge(int8(v))

			case "toys":
				valueList := arrayInStringParser(value)
				v := NewDogToyList(s.Segment, len(valueList))
				for i, vs := range valueList {
					elem := NewDogToy(s.Segment)
					elem.ReadCapLit(bytes.NewReader([]byte(vs)))
					v.Set(i, elem)
				}
				s.SetToys(v)

			default:
				return parseError
			}

			substatus = ""
		}
	}

	if substatus != "" {
		return parseError
	}

	return nil
}

func (s Dog) GetSegment() *capn.Segment { return s.Segment }
